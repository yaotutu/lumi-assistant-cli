syntax = "proto3";

package lumi;

/**
 * Lumi Assistant - AI语音助手gRPC服务接口
 * 
 * 接口设计理念：
 * 1. 任务驱动架构 - 所有操作立即返回task_id，异步处理
 * 2. 事件流系统 - 通过GetEventStream实时接收处理进度和结果
 * 3. 未来扩展 - 预留流式接口支持高级功能
 * 
 * 提供完整的AI语音助手功能：
 * - 语音录制和识别 (ASR)
 * - 智能文本对话 (LLM)
 * - 语音合成 (TTS)
 * - 会话管理和持久化
 * - 系统状态监控和健康检查
 * - 流式处理支持（预留扩展）
 */
service LumiAssistant {
  // === 当前实现的接口 ===
  
  /**
   * 开始录音
   * 
   * 功能：启动麦克风录音，立即返回task_id
   * 流程：请求 → 立即返回task_id → 异步启动录音 → 发送RECORDING_STARTED事件
   * 注意：同时只能有一个录音任务，重复调用会返回失败
   */
  rpc StartRecording(StartRecordingRequest) returns (StartRecordingResponse);
  
  /**
   * 停止录音
   * 
   * 功能：停止麦克风录音，启动音频处理链路
   * 流程：请求 → 立即返回task_id → 停止录音 → ASR识别 → LLM处理 → TTS合成 → 音频播放
   * 事件：RECORDING_STOPPED → ASR_RESULT → LLM_CHUNK... → LLM_COMPLETE → TTS_STARTED → TTS_COMPLETE → TASK_COMPLETE
   * 注意：只有在录音状态下才能调用，否则返回失败
   */
  rpc StopRecording(StopRecordingRequest) returns (StopRecordingResponse);
  
  /**
   * 发送文本消息
   * 
   * 功能：直接发送文本消息到LLM进行对话
   * 流程：请求 → 立即返回task_id → LLM处理 → TTS合成 → 音频播放
   * 事件：LLM_CHUNK... → LLM_COMPLETE → TTS_STARTED → TTS_COMPLETE → TASK_COMPLETE
   * 优势：跳过录音和ASR步骤，直接进入文本对话模式
   */
  rpc SendText(SendTextRequest) returns (SendTextResponse);
  
  /**
   * 获取实时事件流
   * 
   * 功能：订阅所有任务的实时处理事件
   * 事件类型：
   * - RECORDING_STARTED/STOPPED: 录音状态变化
   * - ASR_RESULT: 语音识别结果
   * - LLM_CHUNK: LLM流式响应片段
   * - LLM_COMPLETE: LLM响应完成
   * - TTS_STARTED/COMPLETE: 语音合成状态
   * - TASK_COMPLETE: 整个任务完成
   * - TASK_ERROR: 任务执行出错
   * 
   * 使用建议：客户端应在启动时立即订阅此流，以接收所有任务的实时反馈
   */
  rpc GetEventStream(Empty) returns (stream ProcessEvent);
  
  // === 会话管理接口 ===
  // 支持多会话管理，包括创建、切换、持久化存储
  
  /**
   * 创建新会话
   * 
   * 功能：创建一个新的对话会话，清空上下文历史
   * 使用场景：开始新的话题或清空对话历史
   * 注意：新会话会成为当前活跃会话，后续所有对话都在此会话中进行
   */
  rpc NewSession (NewSessionRequest) returns (NewSessionResponse);
  
  /**
   * 获取当前活跃会话信息
   * 
   * 功能：获取当前正在使用的会话的详细信息
   * 返回信息：会话session_id、创建时间、消息数量、会话标题
   */
  rpc GetSessionInfo (GetSessionInfoRequest) returns (GetSessionInfoResponse);
  
  /**
   * 列出历史会话列表
   * 
   * 功能：获取历史会话列表，按时间倒序排列
   * 参数：limit 限制返回数量，默认为10个
   * 使用场景：展示对话历史，支持用户选择恢复历史会话
   */
  rpc ListSessions (ListSessionsRequest) returns (ListSessionsResponse);
  
  /**
   * 加载指定历史会话
   * 
   * 功能：切换到指定的历史会话，恢复上下文历史
   * 参数：session_id 需要加载的会话唯一标识符
   * 效果：加载成功后，该会话成为当前活跃会话，后续对话在此基础上继续
   */
  rpc LoadSession (LoadSessionRequest) returns (LoadSessionResponse);
  
  // === 系统状态监控接口 ===
  // 用于监控服务器运行状态和性能指标
  
  /**
   * 获取系统实时状态
   * 
   * 功能：获取服务器当前的运行状态和统计信息
   * 返回信息：
   * - is_recording: 是否正在录音
   * - active_tasks: 当前正在处理的任务数量
   * - active_clients: 当前连接的客户端数量
   */
  rpc GetStatus (Empty) returns (StatusResponse);
  
  /**
   * 系统健康检查
   * 
   * 功能：全面检查服务器和各组件的健康状态
   * 检查项目：
   * - ASR服务可用性
   * - LLM服务可用性 
   * - TTS服务可用性
   * - 系统整体健康状态
   * 返回信息：版本号、健康状态、各服务组件状态列表
   * 使用场景：服务监控、负载均衡检查、故障诊断
   */
  rpc HealthCheck (HealthCheckRequest) returns (HealthCheckResponse);
  
  // === 未来流式接口（预留扩展） ===
  // 这些接口为未来的高级功能做准备，目前返回UNIMPLEMENTED状态
  
  /**
   * 流式语音识别（未来实现）
   * 
   * 预期功能：实时接收音频流，实时返回ASR结果
   * 优势：更低延迟、支持长时间连续识别、部分结果实时反馈
   * 适用场景：实时对话、语音输入法、会议记录
   */
  rpc StreamASR(stream AudioChunk) returns (stream ASRResult);
  
  /**
   * 流式语音合成（未来实现）
   * 
   * 预期功能：实时接收文本流，按段落生成音频并流式返回
   * 优势：更低首字延迟、支持超长文本、实时播放
   * 适用场景：实时播音、有声书、直播室
   */
  rpc StreamTTS(stream TTSRequest) returns (stream AudioChunk);
  
  /**
   * 双向流式对话（未来实现）
   * 
   * 预期功能：统一的双向流式接口，支持音频、文本、命令混合输入
   * 优势：更简单的客户端集成、更低的连接开销、更高的并发性能
   * 适用场景：完全流式对话系统、多模态交互、高并发场景
   */
  rpc StreamConversation(stream ConversationInput) returns (stream ConversationOutput);
}

// === 通用基础消息 ===

/**
 * 空消息
 * 用于不需要参数的RPC调用
 */
message Empty {}

// === 当前已实现接口的消息类型 ===

/**
 * 开始录音请求
 * 无需参数，空消息即可
 */
message StartRecordingRequest {}

/**
 * 开始录音响应
 */
message StartRecordingResponse {
  bool success = 1;     // 操作是否成功
  string task_id = 2;   // 任务唯一标识符，成功时返回
  string error = 3;     // 失败时的错误信息
}

/**
 * 停止录音请求
 * 无需参数，空消息即可
 */
message StopRecordingRequest {}

/**
 * 停止录音响应
 */
message StopRecordingResponse {
  bool success = 1;     // 操作是否成功
  string task_id = 2;   // 任务唯一标识符，成功时返回
  string error = 3;     // 失败时的错误信息
}

/**
 * 发送文本请求
 */
message SendTextRequest {
  string text = 1;      // 要发送给LLM的文本内容，不能为空
}

/**
 * 发送文本响应
 */
message SendTextResponse {
  bool success = 1;     // 操作是否成功
  string task_id = 2;   // 任务唯一标识符，成功时返回
  string error = 3;     // 失败时的错误信息
}

/**
 * 实时事件消息
 * 通过GetEventStream流式返回，包含所有任务的处理进度和结果
 */
message ProcessEvent {
  string task_id = 1;   // 对应的任务ID，用于匹配请求和响应
  EventType type = 2;   // 事件类型，详见EventType枚举
  string content = 3;   // 事件内容，如LLM响应的文本片段
  int64 timestamp = 4;  // 事件时间戳（毫秒）
  
  // 预留扩展字段，用于未来流式接口的详细数据
  oneof event_data {
    ASREventData asr_data = 10;     // ASR详细数据（未来扩展）
    TTSEventData tts_data = 11;     // TTS详细数据（未来扩展）
    AudioEventData audio_data = 12; // 音频详细数据（未来扩展）
  }
}

/**
 * 事件类型枚举
 * 定义所有可能的事件类型，包括当前实现和未来扩展
 */
enum EventType {
  // === 当前已实现的事件类型 ===
  RECORDING_STARTED = 0;  // 录音开始，无content
  RECORDING_STOPPED = 1;  // 录音停止，无content
  ASR_RESULT = 2;         // 语音识别结果，content为识别文本
  LLM_CHUNK = 3;          // LLM流式响应片段，content为文本片段
  LLM_COMPLETE = 4;       // LLM响应完成，无content
  TTS_STARTED = 5;        // 语音合成开始，无content
  TTS_COMPLETE = 6;       // 语音合成完成，无content
  TASK_ERROR = 7;         // 任务执行出错，content为错误信息
  TASK_COMPLETE = 8;      // 整个任务完成，无content
  
  // === 预留的流式事件类型（未来扩展） ===
  ASR_STREAM_STARTED = 20;  // 流式ASR开始
  ASR_PARTIAL_RESULT = 21;  // 流式ASR部分结果
  ASR_FINAL_RESULT = 22;    // 流式ASR最终结果
  ASR_STREAM_ENDED = 23;    // 流式ASR结束
  
  TTS_STREAM_STARTED = 30;  // 流式TTS开始
  TTS_AUDIO_CHUNK = 31;     // 流式TTS音频片段
  TTS_STREAM_ENDED = 32;    // 流式TTS结束
  
  AUDIO_LEVEL_UPDATE = 40;  // 音频电平更新
  VAD_DETECTED = 41;        // 声音活动检测
}

// === 扩展数据结构（预留） ===

/**
 * ASR事件详细数据
 */
message ASREventData {
  string text = 1;
  float confidence = 2;
  bool is_partial = 3;
  int64 start_time_ms = 4;
  int64 end_time_ms = 5;
  repeated WordAlignment words = 6;
}

/**
 * TTS事件详细数据
 */
message TTSEventData {
  bytes audio_data = 1;
  string format = 2;
  int32 sample_rate = 3;
  int32 duration_ms = 4;
}

/**
 * 音频事件数据
 */
message AudioEventData {
  float level = 1;
  bool voice_detected = 2;
  string audio_format = 3;
}

/**
 * 词对齐信息
 */
message WordAlignment {
  string word = 1;
  int64 start_time_ms = 2;
  int64 end_time_ms = 3;
  float confidence = 4;
}

// === 会话管理接口消息 ===

/**
 * 创建新会话请求
 */
message NewSessionRequest {
  string source = 1;    // 请求来源标识（可选），用于日志记录
}

/**
 * 创建新会话响应
 */
message NewSessionResponse {
  bool success = 1;     // 操作是否成功
  string session_id = 2;// 新创建的会话唯一标识符
  string error = 3;     // 失败时的错误信息
}

/**
 * 获取当前会话信息请求
 * 无需参数，空消息即可
 */
message GetSessionInfoRequest {}

/**
 * 获取当前会话信息响应
 */
message GetSessionInfoResponse {
  bool success = 1;           // 操作是否成功
  SessionInfo session_info = 2;// 当前会话的详细信息
  string error = 3;           // 失败时的错误信息
}

/**
 * 会话信息结构
 * 包含会话的基本元信息
 */
message SessionInfo {
  string session_id = 1;    // 会话唯一标识符
  string created_at = 2;    // 创建时间（ISO 8601格式）
  int32 message_count = 3;  // 会话中的消息数量
  string title = 4;         // 会话标题（一般为第一条消息的简短摘要）
}

/**
 * 列出历史会话请求
 */
message ListSessionsRequest {
  int32 limit = 1;      // 返回数量限制，默认为10，最大100
}

/**
 * 列出历史会话响应
 */
message ListSessionsResponse {
  bool success = 1;               // 操作是否成功
  repeated SessionInfo sessions = 2;// 会话列表，按创建时间倒序排列
  string error = 3;               // 失败时的错误信息
}

/**
 * 加载指定会话请求
 */
message LoadSessionRequest {
  string session_id = 1;// 要加载的会话唯一标识符
  string source = 2;    // 请求来源标识（可选），用于日志记录
}

/**
 * 加载指定会话响应
 */
message LoadSessionResponse {
  bool success = 1;     // 操作是否成功
  string message = 2;   // 成功时的确认信息
  string error = 3;     // 失败时的错误信息
}

// === 系统状态消息 ===

/**
 * 系统状态响应
 * 返回服务器当前的实时运行状态
 */
message StatusResponse {
  bool is_recording = 1;     // 是否正在录音（语音模式状态）
  int32 active_tasks = 2;    // 当前正在处理的任务数量
  int32 active_clients = 3;  // 当前连接的gRPC客户端数量
}

/**
 * 健康检查请求
 * 无需参数，空消息即可
 */
message HealthCheckRequest {}

/**
 * 健康检查响应
 * 提供全面的系统健康状态信息
 */
message HealthCheckResponse {
  bool is_healthy = 1;              // 系统整体健康状态
  string message = 2;               // 健康状态描述信息
  string version = 3;               // 服务版本号
  repeated ServiceStatus services = 4; // 各个服务组件的详细状态列表
}

/**
 * 服务组件状态
 * 描述单个服务组件的状态信息
 */
message ServiceStatus {
  string name = 1;        // 服务组件名称（如"ASR", "LLM", "TTS"）
  bool available = 2;     // 服务是否可用
  string status = 3;      // 服务状态详细描述
}

// === 预留的流式接口消息（未来扩展） ===

/**
 * 音频数据块
 * 用于流式音频传输，支持多种音频格式
 */
message AudioChunk {
  bytes data = 1;         // 音频二进制数据
  string format = 2;      // 音频格式（如"pcm", "wav", "mp3"）
  int64 timestamp = 3;    // 音频时间戳（毫秒）
  bool is_final = 4;      // 是否为最后一个音频块
}

/**
 * 流式ASR识别结果
 * 支持部分结果和最终结果，包含置信度和词对齐
 */
message ASRResult {
  string text = 1;                    // 识别的文本内容
  float confidence = 2;               // 识别置信度（0.0-1.0）
  bool is_partial = 3;                // 是否为部分结果（false表示最终结果）
  repeated WordAlignment words = 4;   // 词级别的时间对齐信息
}

/**
 * 流式TTS合成请求
 * 支持流式文本输入和语音参数控制
 */
message TTSRequest {
  string text = 1;      // 要合成的文本片段
  string voice = 2;     // 语音类型（如"zhixiaobai", "xiaoyun"）
  float speed = 3;      // 语速倍数（0.5-2.0，1.0为正常语速）
  float pitch = 4;      // 音调调整（-12.0到12.0，0为正常音调）
  bool is_final = 5;    // 是否为最后一个文本片段
}

/**
 * 统一对话输入
 * 支持多模态输入：音频、文本、控制命令
 */
message ConversationInput {
  oneof input_type {
    AudioChunk audio = 1;   // 音频输入（用于语音识别）
    string text = 2;        // 文本输入（直接对话）
    string command = 3;     // 控制命令（如"stop", "pause", "resume"）
  }
}

/**
 * 统一对话输出
 * 支持多模态输出：文本、音频、事件通知
 */
message ConversationOutput {
  oneof output_type {
    string text = 1;          // 文本输出（LLM响应）
    AudioChunk audio = 2;     // 音频输出（TTS合成音频）
    ProcessEvent event = 3;   // 事件通知（状态更新）
  }
}

/*
 * ===== 使用说明 =====
 * 
 * 1. 基本工作流程：
 *    a) 语音交互：StartRecording() -> StopRecording()
 *       - StartRecording立即返回task_id，开始录音
 *       - StopRecording立即返回task_id，停止录音并启动处理链路
 *       - 通过GetEventStream()监听处理进度和结果
 *    
 *    b) 文本交互：SendText()
 *       - 立即返回task_id，开始LLM处理
 *       - 通过GetEventStream()接收LLM流式响应和TTS结果
 *    
 *    c) 会话管理：NewSession() / LoadSession() / ListSessions()
 *       - 创建新会话或切换到历史会话
 *       - 会话包含完整的对话历史和上下文
 * 
 * 2. 事件流处理（核心机制）：
 *    - 客户端应在启动时立即调用GetEventStream()建立事件流连接
 *    - 所有异步处理结果都通过事件流实时推送
 *    - 根据task_id匹配请求和对应的事件
 *    - 事件类型包括：录音状态、ASR结果、LLM响应、TTS状态、任务完成等
 * 
 * 3. 错误处理：
 *    - 所有同步响应都包含success字段，表示操作是否成功启动
 *    - 失败时error字段包含具体错误信息
 *    - 异步处理错误通过TASK_ERROR事件推送
 *    - 建议定期调用HealthCheck()检查系统整体状态
 * 
 * 4. 会话机制：
 *    - 系统维护一个"当前活跃会话"概念
 *    - 所有对话操作都在当前活跃会话的上下文中进行
 *    - NewSession()创建新会话并设为活跃会话
 *    - LoadSession()切换到指定历史会话并设为活跃会话
 *    - GetSessionInfo()获取当前活跃会话信息
 * 
 * 5. 系统状态监控：
 *    - GetStatus()获取实时运行状态（录音状态、任务数量、客户端数量）
 *    - HealthCheck()获取详细健康状态（服务可用性、版本信息）
 *    - 支持多客户端并发连接和操作
 * 
 * 6. 典型客户端实现模式：
 *    - 启动时：HealthCheck() -> GetEventStream() -> NewSession()
 *    - 语音交互：StartRecording() -> 用户说话 -> StopRecording() -> 监听事件
 *    - 文本交互：SendText() -> 监听事件
 *    - 会话切换：ListSessions() -> LoadSession()
 *    - 关闭时：取消事件流订阅
 * 
 * 7. 未来扩展考虑：
 *    - 当前接口为立即响应+事件流模式，适合当前需求
 *    - 预留的流式接口（StreamASR、StreamTTS、StreamConversation）
 *      将提供更高级的流式处理能力
 *    - 扩展数据结构已预留，支持无缝升级
 */